### [204\. 计数质数](https://leetcode-cn.com/problems/count-primes/description/)

Difficulty: **简单**


统计所有小于非负整数 _n _的质数的数量。

**示例:**

```
输入: 10
输出: 4
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
```


#### Solution

Language: **Java**

```
204. 计数质数
1.一般思路：
    遍历2-n，根据质数性质, 判断每个数是不是质数, 累加质数的个数
2.质数的性质反用, 质数的倍数不再是质数
总结:
    1.性质的正反利用(逆向思维)
    2.优化, 是对案例的分析, 推演, 多动笔
​1.质数的性质反用, 标记位+线性扫描判断n内质数的性质
    2是质数, 2*2, 2*3, ... 都是合数
    问题:
    有重复遍历, 比如质数2 2*3 质数3*2
    时间复杂度: O(n)
    空间复杂度: O(n)
2.对上代码进行优化
    a.第二次遍历, 可以在第一次遍历中完成
    b.从 i * i 开始，因为如果 k < i，那么 k * i 在之前就已经被去除过了(去除之前的重复遍历)
    时间复杂度: O(n)
    空间复杂度: O(n)
3.对上代码进一步优化[偶数>2 都是合数, 我们可以不遍历]
    a.仅对奇数进行判断, 从3开始的奇数判断素数与否
    b.奇数(2n+1)有n个奇数, 偶数(2n)有n个奇数, 不包括当前数. 将2看作1. 初始个位为n/2个
    c.i * i = n的性质再次利用, i能处理n中的所有非素数, n=a*b, a!=b, a和b中有一个 < i
    时间复杂度: O(n/2) => O(n)
    空间复杂度: O(n)
```
2.最大公约数
3.最大公倍数
### [504\. 七进制数](https://leetcode-cn.com/problems/base-7/description/)

Difficulty: **简单**


给定一个整数，将其转化为7进制，并以字符串形式输出。

**示例 1:**

```
输入: 100
输出: "202"
```

**示例 2:**

```
输入: -7
输出: "-10"
```

**注意:** 输入范围是 [-1e7, 1e7] 。


#### Solution

Language: **Java**

```
实质: 数学
504. 七进制数
    1.利用API
    2.根据进制的性质
1.使用API
2.进制转换
    时间复杂度: O(log7(num))
    空间复杂度: O(log7(num))
```
### [405\. 数字转换为十六进制数](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/)

Difficulty: **简单**


给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用  方法。

**注意:**

1.  十六进制中所有字母(`a-f`)都必须是小写。
2.  十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符`'0'`来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 
3.  给定的数确保在32位有符号整数范围内。
4.  **不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。**

**示例 1：**

```
输入:
26

输出:
"1a"
```

**示例 2：**

```
输入:
-1

输出:
"ffffffff"
```


#### Solution

Language: **Java**

```
实质考察: 位运算
405. 数字转换为十六进制数
1.第一个问题, a-f的映射问题
解决方式: 建立数组映射 索引-十六进制
2.十六进制的独特性质, 除法通过位运算(右移4位)实现
3.逻辑右移和判断不等于0完成迭代(负数是用补码形式)
1.位运算
映射
时间复杂度: O(1)
空间复杂度: O(1)
​
```
### [168\. Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/description/)

Difficulty: **简单**


给定一个正整数，返回它在 Excel 表中相对应的列名称。

例如，

```
    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB 
    ...
```

**示例 1:**

```
输入: 1
输出: "A"
```

**示例 2:**

```
输入: 28
输出: "AB"
```

**示例 3:**

```
输入: 701
输出: "ZY"
```


#### Solution

Language: **Java**

```
168. Excel表列名称
    考察: 数学
    [因为是从 1 开始计算的，而不是从 0 开始，因此需要对 n 执行 -1 操作。]
    0-9进制与A-Z进制, 后者是没有0的进制, 二者转换需要加入-1操作
​1.迭代
    时间复杂度: O(log26(n))
    空间复杂度: O(log26(n))
2.递归
    时间复杂度: O(log26(n))
    空间复杂度: O(log26(n))
```
### [172\. 阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/description/)

Difficulty: **简单**


给定一个整数 _n_，返回 _n_! 结果尾数中零的数量。

**示例 1:**

```
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```

**示例 2:**

```
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```

**说明:** 你算法的时间复杂度应为 _O_(log _n_)。


#### Solution

Language: **Java**

```
172. 阶乘后的零
    考察: 数学问题
    思考:
        1.5*偶数=10,偶数足够多, 只考虑5即可
        2.25是5*5, 125是5*5*5
    总结:
        一个数含有5的倍数个数 + 含有25个数的倍数 + 含有125的个数.....
​1.递归
    时间复杂度: O(log5(n))
    空间复杂度: O(log5(n))
2.迭代
    时间复杂度: O(log5(n))
    空间复杂度: O(1)
```
### [67\. 二进制求和](https://leetcode-cn.com/problems/add-binary/)

Difficulty: **简单**


给你两个二进制字符串，返回它们的和（用二进制表示）。

输入为 **非空** 字符串且只包含数字 `1` 和 `0`。

**示例 1:**

```
输入: a = "11", b = "1"
输出: "100"
```

**示例 2:**

```
输入: a = "1010", b = "1011"
输出: "10101"
```

**提示：**

*   每个字符串仅由字符 `'0'` 或 `'1'` 组成。
*   `1 <= a.length, b.length <= 10^4`
*   字符串如果不是 `"0"` ，就都不含前导零。


#### Solution

Language: **Java**

```
67. 二进制求和
    考察: 数学 字符串 整数溢出
​1.直接操作字符串(模拟两数相加)
    时间复杂度: O(n)  n:a,b字符串中, 长的
    空间复杂度: O(n)
2.使用API
    存在整数溢出的问题
```
### [415\. 字符串相加](https://leetcode-cn.com/problems/add-strings/)

Difficulty: **简单**


给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和。

**注意：**

1.  `num1` 和`num2` 的长度都小于 5100.
2.  `num1` 和`num2` 都只包含数字 `0-9`.
3.  `num1` 和`num2` 都不包含任何前导零。
4.  **你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。**


#### Solution

Language: **Java**

```
415. 字符串相加
    考察: 数学 字符串 转成数可能存在整数溢出问题
1.操作字符串
    时间复杂度: O(max(num1, num2))
    空间复杂度: O(max(num1, num2))
```
### [462\. 最少移动次数使数组元素相等 II](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/description/)

Difficulty: **中等**


给定一个非空整数数组，找到使所有数组元素相等所需的最小移动数，其中每次移动可将选定的一个元素加1或减1。 您可以假设数组的长度最多为10000。

**例如:**

```
输入:
[1,2,3]

输出:
2

说明：
只有两个动作是必要的（记得每一步仅可使其中一个元素加1或减1）： 

[1,2,3]  =>  [2,2,3]  =>  [2,2,2]
```


#### Solution

Language: **Java**

```
462. 最少移动次数使数组元素相等 II
解题思想:
    这题不用想什么中位数：设 a <= x <= b，将 a 和 b 都变化成 x 为最终目的，
    则需要步数为 x-a+b-x = b-a，即两个数最后相等的话步数一定是他们的差，x 在 a 和 b 间任意取；
    所以最后剩的其实就是中位数；那么直接排序后首尾指针计算就好：
问题实质, 中位数是最优, 对于偶数数列, [pivot-1, pivot+1]区间任意整数都可以
​1.排序
    时间复杂度: O(nlog2(n))
    空间复杂度: O(log2(n))`   排序所需要的空间
2.快速选择, 寻找中位数
    时间复杂度: O(n)  最差O(n^2)
    空间复杂度: O(log2(n))
```
### [169\. 多数元素](https://leetcode-cn.com/problems/majority-element/)

Difficulty: **简单**


给定一个大小为 _n_ 的数组，找到其中的多数元素。多数元素是指在数组中出现次数**大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1:**

```
输入: [3,2,3]
输出: 3
```

**示例 2:**

```
输入: [2,2,1,1,1,2,2]
输出: 2
```


#### Solution

Language: **Java**

```
169. 多数元素
    解法:
        1.暴力解法
        2.哈希表
        3.随机化(统计学)
        4.分治算法
        5.摩尔投票
            此处的多数元素需要超过一半
​1.排序
    问题没有利用 多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素 性质。
    时间复杂度: O(n*log2(n))
    空间复杂度: O(1)
2.Boyer-Moore Majority Vote Algorithm
    充分利用多数元素过半数的性质   [妙]
    时间复杂度: O(n)
    空间复杂度: O(1)
证明:
    如果候选人不是maj 则 maj,会和其他非候选人一起反对 会反对候选人,所以候选人一定会下台(maj==0时发生换届选举)
    如果候选人是maj , 则maj 会支持自己，其他候选人会反对，同样因为maj 票数超过一半，所以maj 一定会成功当选
```
### [367\. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/description/)

Difficulty: **简单**


给定一个正整数 _num_，编写一个函数，如果 _num_ 是一个完全平方数，则返回 True，否则返回 False。

**说明：**不要使用任何内置的库函数，如  `sqrt`。

**示例 1：**

```
输入：16
输出：True
```

**示例 2：**

```
输入：14
输出：False
```


#### Solution

Language: **Java**

```
367. 有效的完全平方数
    完全平方数性质: 完全平方数=sqrt(n)个奇数相加
    处理int溢出: long*int, 有一个数需要先进制转换(long)
1.利用完全平方数的性质: 完全平方数=sqrt(n)个奇数相加
    时间复杂度: O(sqrt(n))
    空间复杂度: O(1)
​2.二分查找
    处理整数溢出问题
    时间复杂度: O(log2(n))
    效率优于前者
    空间复杂度: O(1)
3.牛顿迭代法
    时间复杂度: O(log2(n))
    空间复杂度: O(1)
```
### [326\. 3的幂](https://leetcode-cn.com/problems/power-of-three/)

Difficulty: **简单**


给定一个整数，写一个函数来判断它是否是 3 的幂次方。

**示例 1:**

```
输入: 27
输出: true
```

**示例 2:**

```
输入: 0
输出: false
```

**示例 3:**

```
输入: 9
输出: true
```

**示例 4:**

```
输入: 45
输出: false
```

**进阶：**  
你能不使用循环或者递归来完成本题吗？


#### Solution

Language: **Java**

```
326. 3的幂
    考察：数学
    1.3的幂, 可以一直被三整除, 直至等于1
    2.int中, 最大的3的幂是1162261467, 其他3的幂都是它的因式
1.迭代法
    时间复杂度: O(log3(n))
    空间复杂度: O(1)
​2.3的幂的性质
    时间复杂度: O(1)
    空间复杂度: O(1)
```
### [238\. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/description/)

Difficulty: **中等**


给你一个长度为 _n_ 的整数数组 `nums`，其中 _n_ > 1，返回输出数组 `output` ，其中 `output[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。

**示例:**

```
输入: [1,2,3,4]
输出: [24,12,8,6]
```

**提示：**题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。

**说明:** 请**不要使用除法，**且在 O(_n_) 时间复杂度内完成此题。

**进阶：**  
你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组**不被视为**额外空间。）


#### Solution

Language: **Java**

```
238. 除自身以外数组的乘积
思考:
    1.最直接的方式, 创建一个长度等于nums的数组, 用nums数组的各个元素相乘填充, 遍历除以每个索引对应的值
    2.题目中, 不允许使用除法
        - 左右两个数组, 一个是从左到右乘, 一个从右到左乘, 两个对应元素互乘
        - 不使用两个数组, 使用中间变量累乘, 再与数组对应元素相乘 [空间复杂度:1]
体会:
    重复利用之前已经做过的工作, 减去重复工作
​1.左右
    时间复杂度: O(n)
    空间复杂度: O(1)
```
### [628\. 三个数的最大乘积](https://leetcode-cn.com/problems/maximum-product-of-three-numbers/)

Difficulty: **简单**


给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。

**示例 1:**

```
输入: [1,2,3]
输出: 6
```

**示例 2:**

```
输入: [1,2,3,4]
输出: 24
```

**注意:**

1.  给定的整型数组长度范围是[3,10<sup>4</sup>]，数组中所有的元素范围是[-1000, 1000]。
2.  输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。


#### Solution

Language: **Java**

```
628. 三个数的最大乘积
     教训: 一开始未考虑负数的问题, 错误判断找三个最大的数
     思路:
         最大三个数相乘 or 最小二数*最大一数(负负得正)
         1.排序
         2.一次遍历, 中间变量记录
​1.堆结构
    错误: 未考虑负数
    反思: 最大数为 三个最大相乘 | 两个最小*最大
2.排序
    时间复杂度: O(n*log2(n))
    空间复杂度: O(1)
3.线性扫描
    时间复杂度: O(n)
    空间复杂度: O(1)
```




















