### [215\. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/)

Difficulty: **中等**


在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

**示例 1:**

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```

**说明:**

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。


#### Solution

Language: **Java**

```
1. 调用API
    时间复杂度: O(nlogn) =>排序算法的复杂度
    空间复杂度: O(1)
2. 利用大顶堆, 找出第k个大, 手写
    时间复杂度:O(klogn)
    空间复杂度:O(1)
3. 利用PriorityQueue优先对列的小顶堆, 保证k个元素的小顶堆
    时间复杂度: O(nlogk)
    空间复杂度: O(k)
4. 快速选择 找到第索引nums.length-k个轴(索引从0开始) => 即为第k个大的元素
    时间复杂度: O(n)
    空间复杂度: O(1)
​
```

### [347\. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

Difficulty: **中等**


给定一个非空的整数数组，返回其中出现频率前 **_k _**高的元素。

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```

**提示：**

*   你可以假设给定的 _k _总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
*   你的算法的时间复杂度**必须**优于 O(_n_ log _n_) , _n _是数组的大小。
*   题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。
*   你可以按任意顺序返回答案。


#### Solution

Language: **Java**

```
0. API排序
    时间复杂度: O(nlogn)
    空间复杂度: O(1)
这个题目有他的独特性, 没必要整个数组排好序
1. 堆排序(小顶堆)
    时间复杂度: O(nlogk)
    空间复杂度: O(n)
注意:
    匿名函数能使用外部的变量. Comparator匿名函数
2. 桶排序(桶的个数 => 数组长度+1)
    时间复杂度: O(n)
    空间复杂度: O(n)
注意:
    先由哈希表建立元素:重复次数对应关系
    
​
```

### [451\. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)

Difficulty: **中等**


给定一个字符串，请将字符串里的字符按照出现的频率降序排列。

**示例 1:**

```
输入:
"tree"

输出:
"eert"

解释:
'e'出现两次，'r'和't'都只出现一次。
因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。
```

**示例 2:**

```
输入:
"cccaaa"

输出:
"cccaaa"

解释:
'c'和'a'都出现三次。此外，"aaaccc"也是有效的答案。
注意"cacaca"是不正确的，因为相同的字母必须放在一起。
```

**示例 3:**

```
输入:
"Aabb"

输出:
"bbAa"

解释:
此外，"bbaA"也是一个有效的答案，但"Aabb"是不正确的。
注意'A'和'a'被认为是两种不同的字符。
```


#### Solution

Language: **Java**

```
1. 堆排序法
2. 桶排序法
与 上一道题类似
​
```
### [75\. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

Difficulty: **中等**


给定一个包含红色、白色和蓝色，一共 _n_ 个元素的数组，对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

**注意:**  
不能使用代码库中的排序函数来解决这道题。

**示例:**

```
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```

**进阶：**

*   一个直观的解决方案是使用计数排序的两趟扫描算法。  
    首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
*   你能想出一个仅使用常数空间的一趟扫描算法吗？


#### Solution

Language: **Java**

```
荷兰国旗问题
1. 一次遍历(三指针法)
    时间复杂度: O(N)
    空间复杂度: O(1)
注意:
    三条原则
    遇到的问题, 已经扫描的没有2了, 所以one和zero交换 二者++
                    one和two相换,可能存在0, two-- one不变
                    one=1, one++
​
```