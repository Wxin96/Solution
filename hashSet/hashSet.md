### [1\. 两数之和](https://leetcode-cn.com/problems/two-sum/)

Difficulty: **简单**


给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

**示例:**

```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```


#### Solution

Language: **Java**

```
1.HashSet法
    时间复杂度: O(n)  n:数组元素个数
    空间复杂度: O(n)
思考: 1. 带着元素走
     2. 一边遍历/两次遍历法
2.暴力匹配法
    时间复杂度: O(n^2)
    空间复杂度: O(1)
​
```
### [217\. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/description/)

Difficulty: **简单**


给定一个整数数组，判断是否存在重复元素。

如果任意一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。

**示例 1:**

```
输入: [1,2,3,1]
输出: true
```

**示例 2:**

```
输入: [1,2,3,4]
输出: false
```

**示例 3:**

```
输入: [1,1,1,3,3,4,3,2,4,2]
输出: true
```


#### Solution

Language: **Java**

```
1.HashSet方法
    时间复杂度: O(n) n:数组元素个数
    空间复杂度: O(n)
思考: 本题目充分利用了, HashSet的性质(不存重复元素)
2. 暴力匹配
    时间复杂度: O(n^2)
    空间复杂度: O(1)
3. 排序
    时间复杂度: O(nlog2(n))
    空间复杂度: O(1)
    ​
```
### [594\. 最长和谐子序列](https://leetcode-cn.com/problems/longest-harmonious-subsequence/description/)

Difficulty: **简单**


和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。

现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。

**示例 1:**

```
输入: [1,3,2,2,5,2,3,7]
输出: 5
原因: 最长的和谐数组是：[3,2,2,2,3].
```

**说明:** 输入的数组长度最大不超过20,000.


#### Solution

Language: **Java**

```
1.哈希映射 + 单次扫描/两次扫描
    时间复杂度: O(n)
    空间复杂度: O(n)
思考:
    1.数组元素 (映射)=> 哈希表, 利用O(1)的速度查询对应`键`
    2.一次扫描, 动态过程, 需要左右(+1,-1)都计算
    3.两次扫描, 数组的元素都以分析完, 单侧(+1/-1)遍历即可
2. 遍历法(双指针遍历)
    时间复杂度: O(n^2)
    空间复杂度: O(1)
```
### [128\. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/description/)

Difficulty: **困难**


给定一个未排序的整数数组，找出最长连续序列的长度。

要求算法的时间复杂度为 _O(n)_。

**示例:**

```
输入: [100, 4, 200, 1, 3, 2]
输出: 4
解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。
```


#### Solution

Language: **Java**

```
1.暴力法
    时间复杂度: O(n^3)
    空间复杂度: O(1)
思想,
    1. 第一层遍历, 数组元素遍历
    2. 第二层遍历, 从第i个数组元素k, 向后遍历, 查找最长连续序列
    3. 第三层遍历, 确认​k+1...元素存不存在数组中
2.哈希表和线性空间构造(参考官方回答)
    时间复杂度: O(n)  n:数组的元素数目
    尽管在 for 循环中嵌套了一个 while 循环，时间复杂度看起来像是二次方级别的。
    但其实它是线性的算法。因为只有当 currentNum 遇到了一个序列的开始，
    while 循环才会被执行（也就是 currentNum-1 不在数组 nums 里），
    while 循环在整个运行过程中只会被迭代 nn 次。这意味着尽管看起来时间复杂度为 O(n^2) ，
    实际这个嵌套循环只会运行O(n+n)=O(n) 次。所有的计算都是线性时间的，所以总的时间复杂度是 O(n) 的。
    空间复杂度: O(n)
思考:
    1. 利用哈希表的性值, 解决了查询一层循环
    2. 每次都是在k-1元素不在, 从k元素进行查询, 其实对应一个线性空间
3.哈希表(HashMap), 回溯
    时间复杂度: O(n)  n:数组的元素数目
    空间复杂度: O(n)
思考:
    1.与方法二实质相同, 不同实现方式
    2.通过递归回溯, 改变元素的键值, 对于已经过的元素无需继续回溯, 利用之前遍历的记录键值, 实现线性表
```