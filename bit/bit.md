### [461\. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)

Difficulty: **简单**


两个整数之间的指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 `x` 和 `y`，计算它们之间的汉明距离。

**注意：**  
0 ≤ `x`, `y` < 2<sup>31</sup>.

**示例:**

```
输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

上面的箭头指出了对应二进制位不同的位置。
```


#### Solution

Language: **Java**

```
461. 汉明距离
解题思路(问题转化):
    异或, 求1的个数
​1.位运算 + API
    异或运算中1的个数, 为它们之间的汉明距离.
    时间复杂度: O(1)
    空间复杂度: O(1)
2.异或运算, 右移, 判断当前位是否=1, 循环条件x!=0
    时间复杂度: O(1)
    空间复杂度: O(1)
3.异或运算, 不使用API
    通过z &= (z - 1);去除最后一位1, 循环条件 x!=0
    时间复杂度: O(1)
    空间复杂度: O(1)
```
### [136\. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/description/)

Difficulty: **简单**


给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例 1:**

```
输入: [2,2,1]
输出: 1
```

**示例 2:**

```
输入: [4,1,2,1,2]
输出: 4
```


#### Solution

Language: **Java**

```
136. 只出现一次的数字
1.三个数异或
    利用`x^x=0`的特点, 可以将三个数中重复的两个数去除, 只留下另一个数.
    时间复杂度: O(n)
    空间复杂度: O(1)
2.排序
    时间复杂度: O(n*log2(n))
    空间复杂度: O(1)
```
### [268\. 缺失数字](https://leetcode-cn.com/problems/missing-number/description/)

Difficulty: **简单**


给定一个包含 `0, 1, 2, ..., n` 中 _n_ 个数的序列，找出 0 .. _n_ 中没有出现在序列中的那个数。

**示例 1:**

```
输入: [3,0,1]
输出: 2
```

**示例 2:**

```
输入: [9,6,4,2,3,5,7,0,1]
输出: 8
```

**说明:**  
你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?


#### Solution

Language: **Java**

```
268. 缺失数字
    数组索引|元素 映射关系
    1.高斯求和(避免整数溢出问题)
    2.x^x=0 异或操作, 数组索引和元素组成重复
    不要因为与运算, 只想到与运算方法, 要扩展思路
1.总和-所有元素
问题: 可能有整数溢出问题
    时间复杂度: O(n)
    空间复杂度: O(1)
2.与操作
提示: 数组坐标索引也是数
    时间复杂度: O(n)
    空间复杂度: O(1)
3.排序解法
    时间复杂度: O(n*log2(n))
    空间复杂度: O(1)
4.哈希表映射
    时间复杂度: O(n)
    空间复杂度: O(n)
```
### [260\. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/description/)

Difficulty: **中等**


给定一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。

**示例 :**

```
输入: [1,2,1,3,2,5]
输出: [3,5]
```

**注意：**

1.  结果输出的顺序并不重要，对于上面的例子， `[5, 3]` 也是正确答案。
2.  你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？


#### Solution

Language: **Java**

```
260. 只出现一次的数字 III
    位运算 细节(优先级)
    异或去除相同元素, 再利用异或的性质, 二者不同元素=>1, 找到不同元素. 二次遍历, 以不同元素, 区分两数
    上边的操作是利用 掩码的思想
1.位运算
a & (-a) 可以获得a最低的非0位(借以区分两个数) [妙]
    时间复杂度: O(n)
    空间复杂度: O(1)
2.哈希映射
    时间复杂度: O(n)
    空间复杂度: O(n)
3.排序
    时间复杂度: O(n*log2(n))
    空间复杂度: O(1)
```
### [190\. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/description/)

Difficulty: **简单**


颠倒给定的 32 位无符号整数的二进制位。

**示例 1：**

```
输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```

**示例 2：**

```
输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
```

**提示：**

*   请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
*   在 Java 中，编译器使用记法来表示有符号整数。因此，在上面的 **示例 2** 中，输入表示有符号整数 `-3`，输出表示有符号整数 `-1073741825`。

**进阶**:  
如果多次调用这个函数，你将如何优化你的算法？


#### Solution

Language: **Java**

```
190. 颠倒二进制位
    位运算有很多, 异或 算数左移 算数右移 无符号右移 与或非
    多次调用, 查表思想[static关键字]
    分治算法-局部与整体旋转思想
​1.利用API
    2转, 4转, 8转, 4个8反转
2.位运算取反
    时间复杂度: O(1)
    空间复杂度: O(1)
3.乾坤大挪移(分治算法) 类似 API
    时间复杂度: O(1)
    空间复杂度: O(1)
a.进阶 如果多次调用这个函数，你将如何优化你的算法？
如果该函数需要被调用很多次，可以将 int 拆成 4 个 byte，然后缓存 byte 对应的比特位翻转，最后再拼接起来。
另外建表, 方便以后查询提高效率
使用static随类加载创建
    时间复杂度: O(1)
    空间复杂度: O(2^8=265) -> O(1)
```
6. 不用额外变量交换两个整数
程序员代码面试指南 ：P317

    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
### [231\. 2的幂](https://leetcode-cn.com/problems/power-of-two/description/)

Difficulty: **简单**


给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

**示例 1:**

```
输入: 1
输出: true
解释: 20 = 1
```

**示例 2:**

```
输入: 16
输出: true
解释: 24 = 16
```

**示例 3:**

```
输入: 218
输出: false
```


#### Solution

Language: **Java**

```
​231. 2的幂
     去除最后一位1的妙用, n & (n - 1)
     保留最后一位1, n&(n-1) == n
1.位运算 + API
    时间复杂度: O(1)
    空间复杂度: O(1)
2.利用 1000 & 0111 == 0 这种性质，得到以下解法：
    时间复杂度: O(1)
    空间复杂度: O(1)
3.保留最后一位1, n&(n-1) == n
    时间复杂度: O(1)
    空间复杂度: O(1)
```
### [342\. 4的幂](https://leetcode-cn.com/problems/power-of-four/)

Difficulty: **简单**


给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。

**示例 1:**

```
输入: 16
输出: true
```

**示例 2:**

```
输入: 5
输出: false
```

**进阶：**  
你能不使用循环或者递归来完成本题吗？


#### Solution

Language: **Java**

```
342. 4的幂
    灵活使用掩码操作
​1.位运算
 num > 0
 num能被2整除
 num-1中1的个数能被2整除
 时间复杂度: O(1)
 空间复杂度: O(1)
2.位运算+ 掩码(0x55555555)
修改第三个条件
    时间复杂度: O(1)
    空间复杂度: O(1)
3.暴力法+预计算(查表)
    时间复杂度: O(1)
    空间复杂度: O(1)
4.数学运算, log2(num) 是2的整数倍
    时间复杂度: O(1)
    空间复杂度: O(1)
```
### [693\. 交替位二进制数](https://leetcode-cn.com/problems/binary-number-with-alternating-bits/)

Difficulty: **简单**


给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。

**示例 1:**

```
输入: 5
输出: True
解释:
5的二进制数是: 101
```

**示例 2:**

```
输入: 7
输出: False
解释:
7的二进制数是: 111
```

**示例 3:**

```
输入: 11
输出: False
解释:
11的二进制数是: 1011
```

** 示例 4:**

```
输入: 10
输出: True
解释:
10的二进制数是: 1010
```


#### Solution

Language: **Java**

```
1.位运算
思想: 充分利用交替二进制数的性质, 错位异或, 构成末尾全1
    时间复杂度: O(1)
    空间复杂度: O(1)
​3.转化为字符串
4.数学方法, %2 /2 不相等, 右移数直至为0
```
### [476\. 数字的补数](https://leetcode-cn.com/problems/number-complement/description/)

Difficulty: **简单**


给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。

**示例 1:**

```
输入: 5
输出: 2
解释: 5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。
```

**示例 2:**

```
输入: 1
输出: 0
解释: 1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。
```

**注意:**

1.  给定的整数保证在 32 位带符号整数的范围内。
2.  你可以假定二进制数不包含前导零位。
3.  本题与 1009 相同


#### Solution

Language: **Java**

```
476. 数字的补数
    1.掩码
    2.n^1s=~n   (1s位数是可以变的)
​1.位运算(掩码操作) + API
 先求掩码, 再求反码, 二者相与
     时间复杂度: O(1)
     空间复杂度: O(1)
2.位运算(掩码操作) + 自己寻找掩码(迭代)
3.位操作(掩码操作) + 仿源码(Integer.highestOneBit)
```
### [371\. 两整数之和](https://leetcode-cn.com/problems/sum-of-two-integers/)

Difficulty: **简单**


**不使用**运算符 `+` 和 `-` ​​​​​​​，计算两整数 ​​​​​​​`a` 、`b` ​​​​​​​之和。

**示例 1:**

```
输入: a = 1, b = 2
输出: 3
```

**示例 2:**

```
输入: a = -2, b = 3
输出: 1
```


#### Solution

Language: **Java**

```
个人感触:
    1.位运算的灵活运用
    2.递归和迭代的转化
思路：
    1.当位相加 =》 &操作
    2.计算进位 =》 先^后<<
    3.不停迭代直至 进位==0
1.位操作
    时间复杂度: O(n)  a和b的初始进位数目
    空间复杂度: O(1)
​2.递归     [妙]
    时间复杂度: O(n)  a和b的初始进位数目
    空间复杂度: O(1)
```
### [318\. 最大单词长度乘积](https://leetcode-cn.com/problems/maximum-product-of-word-lengths/)

Difficulty: **中等**


给定一个字符串数组 `words`，找到 `length(word[i]) * length(word[j])` 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。

**示例 1:**

```
输入: ["abcw","baz","foo","bar","xtfn","abcdef"]
输出: 16 
解释: 这两个单词为 "abcw", "xtfn"。
```

**示例 2:**

```
输入: ["a","ab","abc","d","cd","bcd","abcd"]
输出: 4 
解释: 这两个单词为 "ab", "cd"。
```

**示例 3:**

```
输入: ["a","aa","aaa","aaaa"]
输出: 0 
解释: 不存在这样的两个单词。
```


#### Solution

Language: **Java**

```
318. 最大单词长度乘积
 [利用位运算检查是否有重复元素]
 小写字母有26个, int的长度为32位
​1.位运算
 本题主要问题是判断两个字符串是否含有相同字符,
 由于字符串只含有小写字符, 总共26位, 因此可以用一个32位的整数来存储每个字符是否出现过
 时间复杂度: O(n^2) n:字符串的个数
 空间复杂度: O(n)
```
### [338\. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)

Difficulty: **中等**


给定一个非负整数 **num**。对于 **0 ≤ i ≤ num** 范围中的每个数字 **i **，计算其二进制数中的 1 的数目并将它们作为数组返回。

**示例 1:**

```
输入: 2
输出: [0,1,1]
```

**示例 2:**

```
输入: 5
输出: [0,1,1,2,1,2]
```

**进阶:**

*   给出时间复杂度为**O(n*sizeof(integer))**的解答非常容易。但你可以在线性时间**O(n)**内用一趟扫描做到吗？
*   要求算法的空间复杂度为**O(n)**。
*   你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 **__builtin_popcount**）来执行此操作。


#### Solution

Language: **Java**

```
338. 比特位计数
    动态规划与位运算的巧妙结合
1.遍历+API
    时间复杂度: O(n^2)
    空间复杂度: O(n)  数组所占用内存
问题:
    之前数信息没有利用上, 比如110的比特数 = 100的比特数 +1
    又或者, 110的比特数 = 11的比特数(与奇偶有关)
总结, 充分利用之前数的信息可以减少时间复杂度
2.位操作+动态规划
n&(n-1)去除最后的那个1
    时间复杂度: O(n)
    空间复杂度: O(n)
3.奇偶操作 + 动态规划
    奇数的比特数 = (i-1)的比特数+1
    偶数的比特数 = (i/2)的比特数
```












