### [242\. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

Difficulty: **简单**


给定两个字符串 _s_ 和 _t_ ，编写一个函数来判断 _t_ 是否是 _s_ 的字母异位词。

**示例 1:**

```
输入: s = "anagram", t = "nagaram"
输出: true
```

**示例 2:**

```
输入: s = "rat", t = "car"
输出: false
```

**说明:**  
你可以假设字符串只包含小写字母。

**进阶:**  
如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？


#### Solution

Language: **Java**

```java
​
```
### [409\. 最长回文串](https://leetcode-cn.com/problems/longest-palindrome/)

Difficulty: **简单**


给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如 `"Aa"` 不能当做一个回文字符串。

**注意:**  
假设字符串的长度不会超过 1010。

**示例 1:**

```
输入:
"abccccdd"

输出:
7

解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```


#### Solution

Language: **Java**

```
本题目两种解决方法,
    1. 哈希表映射
    2. 排序
其中, 哈希表映射方法是优于排序的. 排序算法时间复杂度n*log2(n)
1.哈希表(HashMap)
    思想: 字符串建立映射关系
    时间复杂度: O(n)  n:字符串长度
    空间复杂度: O(1)     一共26个字母
哈希映射的进阶, 
此处体现了, 如果元素有穷，并且范围不大，那么可以用一个布尔数组来存储一个元素是否存在。
例如对于只有小写字符的元素，就可以用一个长度为 26 的布尔数组来存储一个字符集合，使得空间复杂度降低为 O(1)。
​3.排序
 时间复杂度: O(n*log2(n))
 空间复杂度: O(n)
总结,
    Array的API,多了解一下;
```
### [409\. 最长回文串](https://leetcode-cn.com/problems/longest-palindrome/description/)

Difficulty: **简单**


给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如 `"Aa"` 不能当做一个回文字符串。

**注意:**  
假设字符串的长度不会超过 1010。

**示例 1:**

```
输入:
"abccccdd"

输出:
7

解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```


#### Solution

Language: **Java**

```
409.最长回文串
分析题目得, 最长回文串为: 每个字母的最大偶数值相加, 如果有剩余元素, 可+1放在中间.
解决题目的方式, 哈希映射.
1.哈希映射
    时间复杂度: O(n)  n:字符串的长度
    空间复杂度: O(s)  s:字符集大小
小技巧: 
    i - (i&1)       // [求最大偶数]
```
### [205\. 同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/description/)

Difficulty: **简单**


给定两个字符串 _**s **_和 **_t_**，判断它们是否是同构的。

如果 _**s **_中的字符可以被替换得到 **_t _**，那么这两个字符串是同构的。

所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。

**示例 1:**

```
输入: s = "egg", t = "add"
输出: true
```

**示例 2:**

```
输入: s = "foo", t = "bar"
输出: false
```

**示例 3:**

```
输入: s = "paper", t = "title"
输出: true
```

**说明:**  
你可以假设 _**s **_和 **_t_ **具有相同的长度。


#### Solution

Language: **Java**

```
205.同构字符串
说明:
    你可以假设 s 和 t 具有相同的长度。
想法:
    一开始想记录字母的出现个数, 并对两字符串进行比较, 但是这种方式会出现不同构的也具有类似的性质.
​1.哈希映射
    时间复杂度: O(n)  n:字符串长度
    空间复杂度: O(s)  s:字符集长度
映射关系:
    记录对应字符, 上次出现的位置
2.哈希键值映射
    注意: 左右对应, 一一对应, 一对多不对;
    时间复杂度: O(n)  n:字符串长度
    空间复杂度: O(n)
注意:
    s <=> t 需要互相对应
    "abb" => "ccc"
```
### [647\. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

Difficulty: **中等**


给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。

**示例 1:**

```
输入: "abc"
输出: 3
解释: 三个回文子串: "a", "b", "c".
```

**示例 2:**

```
输入: "aaa"
输出: 6
说明: 6个回文子串: "a", "a", "a", "aa", "aa", "aaa".
```

**注意:**

1.  输入的字符串长度不会超过1000。


#### Solution

Language: **Java**

```
1.中心扩展法
    时间复杂度: O(n^2)
    空间复杂度: O(1)
思想:
     1.从字符串中, 中间的位置取两边扩展
     2.分为奇偶两种情况, 个人想法只考虑到了奇数, 漏了偶数
2.动态规划
    dp[i][j] 代表str[i] - str[j]是否是回文子串
    动态规划起始: 考虑单字符和双字符的特殊情况
    状态转移方程 dp[i][j] = dp[i+1][j-1] && str[i]==str[j]
    时间复杂度: O(n^2)
    空间复杂度: O(n^2)
3.KMP算法
​
```
### [9\. 回文数](https://leetcode-cn.com/problems/palindrome-number/description/)

Difficulty: **简单**


判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

**示例 1:**

```
输入: 121
输出: true
```

**示例 2:**

```
输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

**示例 3:**

```
输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
```

**进阶:**

你能不将整数转为字符串来解决这个问题吗？


#### Solution

Language: **Java**

```
9.回文数
    转换为"字符串"操作无脑
    利用回文数的特点, 采用右转置, 需要考虑数字中包含0的情况
    整数的特点, 数中有0, 会降位数
    此处不需要处理溢出问题, 因为x是回文串, 它一定不会溢出
1.数字转换为字符串
    时间复杂度: O(n)  n:数x占的位置(包括 (-)) n:(int)lg(x)
    空间复杂度: O(n)
2.对数字进行取尾数和头数, 比较, 直至剩最后一个数字
    对于有零数字有问题, 比如 100041
    其实没有问题, 有位数的限制, 能保证首尾是对应的数字
    自己出问题的是: digit应该降低两位 /100
    时间复杂度: O(n)  n: x数的位数
    空间复杂度: O(1)
3.根据回文数特性, 生成一个新的数字
    测试中, 10 100测试为true, 代码有bug
    要求不能使用额外空间, 也就不能将整数转化为字符串进行判断
    将整数分成左右两部分, 右边那部分需要转置, 然后判断这两部分是否相等
    还有一点, 注意奇位数和偶位数不同处理
    时间复杂度: O((int)lg(x))
    空间复杂度: O(1)
```
### [696\. 计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/description/)

Difficulty: **简单**


给定一个字符串 `s`，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

重复出现的子串要计算它们出现的次数。

**示例 1 :**

```
输入: "00110011"
输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

请注意，一些重复出现的子串要计算它们出现的次数。

另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
```

**示例 2 :**

```
输入: "10101"
输出: 4
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
```

**注意：**

*   `s.length` 在1到50,000之间。
*   `s` 只包含“0”或“1”字符。


#### Solution

Language: **Java**

```
1.利用链表
问题转化:
 相邻0和1元素的最小个数叠加
时间复杂度: O(n)  n: 字符串元素个数
空间复杂度: O(n)
代码存在问题:
    1.不够优雅
    2.加强细节问题处理
​2.一次遍历
    时间复杂度: O(n)
    空间复杂度: O(1)
    缺少一种直觉判断, 初始方法可以优化, 多次遍历化为一次遍历
```