### [785\. 判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/description/)

Difficulty: **中等**


给定一个无向图`graph`，当这个图为二分图时返回`true`。

如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。

`graph`将会以邻接表方式给出，`graph[i]`表示图中与节点`i`相连的所有节点。每个节点都是一个在`0`到`graph.length-1`之间的整数。这图中没有自环和平行边： `graph[i]` 中不存在`i`，并且`graph[i]`中没有重复的值。

```
示例 1:
输入: [[1,3], [0,2], [1,3], [0,2]]
输出: true
解释: 
无向图如下:
0----1
|    |
|    |
3----2
我们可以将节点分成两组: {0, 2} 和 {1, 3}。
```

```
示例 2:
输入: [[1,2,3], [0,2], [0,1,3], [0,2]]
输出: false
解释: 
无向图如下:
0----1
| \  |
|  \ |
3----2
我们不能将节点分割成两个独立的子集。
```

**注意:**

*   `graph` 的长度范围为 `[1, 100]`。
*   `graph[i]` 中的元素的范围为 `[0, graph.length - 1]`。
*   `graph[i]` 不会包含 `i` 或者有重复的值。
*   图是无向的: 如果`j` 在 `graph[i]`里边, 那么 `i` 也会在 `graph[j]`里边。


#### Solution

Language: **Java**

```
785. 判断二分图
    考察: 图的深度优先遍历和广度优先遍历
1.深度优先遍历
graph是邻接表
思想:
     使用图的深度优先搜索遍历, 对节点进行染色, 检查是否存在冲突
细节:
     1. 图是否几个集合
     2. 深度遍历遇到颜色不同的点不需要继续向下遍历, 因为之前染色已没问题
    时间复杂度: O(n+e), n:节点数目;e:边的数目. 遍历每个节点, 需遍历每条边
    空间复杂度: O(n)
​2.另一种方式(递归)深度优先遍历
 时间复杂度: O(v+e)
 空间复杂度: O(v)
3.广度优先遍历(BFS)
此处需一层|层
    时间复杂度: O(v+e)
    空间复杂度: O(v)
```
### [207\. 课程表](https://leetcode-cn.com/problems/course-schedule/description/)

Difficulty: **中等**


你这个学期必须选修 `numCourse` 门课程，记为 `0` 到 `numCourse-1` 。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：`[0,1]`

给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？

**示例 1:**

```
输入: 2, [[1,0]] 
输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。
```

**示例 2:**

```
输入: 2, [[1,0],[0,1]]
输出: false
解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。
```

**提示：**

1.  输入的先决条件是由 **边缘列表** 表示的图形，而不是 邻接矩阵 。详情请参见。
2.  你可以假定输入的先决条件中没有重复的边。
3.  `1 <= numCourses <= 10^5`


#### Solution

Language: **Java**

```
207.课程表
 拓扑排序是对[有向无圈]图的顶点的一种排序, 使得如果存在一条边从vi到vj的路径, 那么再排序中vj就出现在vi的后边.
 例子:
     课程表(先选某些课, 才能选别的)
 此题考察的是:
     能否完成课程, 并不是给出选修名单, 两种方式解决:
         1.拓扑排序
         2.深度遍历检查是否有圈
 此处的输入:
     图的表示为: 边缘列表
1.拓扑结构(类似: BFS)
思想:
 如果存在圈, 入度表是始终有对应的顶点的值不为0, 存在顶点遍历不到
numCourses: 相当于顶点个数
    时间复杂度: O(v+e)
    空间复杂度: O(v+e)    邻接表
​2.深度优先遍历(DFS)
 原理: 通过深度优先遍历判断图中是否有环
 数组flag标记, -1被别的访问, 0未被访问, 1当前已访问
    时间复杂度: O(V+E)    V:顶点数 E:边数  遍历一个图, 需要访问所有的节点和边
    空间复杂度: O(V+E)    为建立临界表所需要的额外空间, adjacent长度为V, 并存储E条边
 思路: 
    判断有没有环, 递归有进有退是一条鞭, 递归到重复元素是由环. 递归退的时候改变flag为-1代表已访问, 这是深度遍历中的一支, 没有圈没有问题
```
### [210\. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/description/)

Difficulty: **中等**


现在你总共有 _n_ 门课需要选，记为 `0` 到 `n-1`。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: `[0,1]`

给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。

可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。

**示例 1:**

```
输入: 2, [[1,0]] 
输出: [0,1]
解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
```

**示例 2:**

```
输入: 4, [[1,0],[2,0],[3,1],[3,2]]
输出: [0,1,2,3] or [0,2,1,3]
解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
```

**说明:**

1.  输入的先决条件是由**边缘列表**表示的图形，而不是邻接矩阵。详情请参见。
2.  你可以假定输入的先决条件中没有重复的边。

**提示:**

1.  这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。
2.  - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。
3.  拓扑排序也可以通过  完成。


#### Solution

Language: **Java**

```
1.拓扑排序(类似BFS)
    时间复杂度: O(E+V)
    空间复杂度: O(E+V)
​2.DFS
    DFS遍历反向输出
    时间复杂度: O(E+V)
    空间复杂度: O(E+V)
证明：
    对于任何先序关系：v->w，后序遍历结果可以保证 w 先进入栈中，因此栈的逆序结果中 v 会在 w 之前。
```
### [684\. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)

Difficulty: **中等**


在本问题中, 树指的是一个连通且无环的**无向**图。

输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。

结果图是一个以`边`组成的二维数组。每一个`边`的元素是一对`[u, v]` ，满足 `u < v`，表示连接顶点`u` 和`v`的**无向**图的边。

返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 `[u, v]` 应满足相同的格式 `u < v`。

**示例 1：**

```
输入: [[1,2], [1,3], [2,3]]
输出: [2,3]
解释: 给定的无向图为:
  1
 / \
2 - 3
```

**示例 2：**

```
输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]
解释: 给定的无向图为:
5 - 1 - 2
    |   |
    4 - 3
```

**注意:**

*   输入的二维数组大小在 3 到 1000。
*   二维数组中的整数在1到N之间，其中N是输入数组的大小。

**更新(2017-09-26):**  
我们已经重新检查了问题描述及测试用例，明确图是_**无向 **_图。对于有向图详见**。**对于造成任何不便，我们深感歉意。


#### Solution

Language: **Java**

```
684. 冗余连接
    并查集的巧妙应用
    并查集: 查找函数(路径压缩) 联合函数
思路:
    1-N节点的树, 那个任意两个节点只有一条路径相同
​1.并查集2
     时间复杂度: O(N)  N:图中顶点数目以及边的数目
     空间复杂度: O(N)
3.拓扑结构
思想:
    将无向图看作有向图, a-b -> a->b 和 a<-b
    清除入度为1的, 直至无法清除, 剩下为环, 入度都为2
    时间复杂度: O(E+V)
    空间复杂度: O(E+V)
```