### [70\. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/description/)

Difficulty: **简单**


假设你正在爬楼梯。需要 _n_ 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 _n_ 是一个正整数。

**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1\.  1 阶 + 1 阶
2\.  2 阶
```

**示例 2：**

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1\.  1 阶 + 1 阶 + 1 阶
2\.  1 阶 + 2 阶
3\.  2 阶 + 1 阶
```


#### Solution

Language: **Java**

```
1.动态规划
时间复杂度: O(n)
空间复杂度: O(1)
状态转移方程: f(n) = f(n-1) + f(n-2)
Base Case: f(1) = 1, f(2) = 2
当前状态只用到了前两个状态, 可以用[状态压缩], 降低算法的空间复杂度
```
### [198\. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

Difficulty: **简单**


你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

**提示：**

*   `0 <= nums.length <= 100`
*   `0 <= nums[i] <= 400`


#### Solution

Language: **Java**

```
 1.动态规划(状态压缩)
 时间复杂度: O(n)
 空间复杂度: O(1)
 状态转移方程(三间房子): A B C, C=max{A+C, B}
 dp[i] = max{dp[i] + dp[i-1], dp[i-1]}
 dp[0] = 0, dp[1] = nums[0]
```
### [213\. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/description/)

Difficulty: **中等**


你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都**围成一圈，**这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你**在不触动警报装置的情况下，**能够偷窃到的最高金额。

**示例 1:**

```
输入: [2,3,2]
输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

**示例 2:**

```
输入: [1,2,3,1]
输出: 4
解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```


#### Solution

Language: **Java**

```
1.动态规划
时间复杂度: O(n)
空间复杂度: O(1)
既然位置0和len-1相邻, 两个只能取一个, 求0-(len-2)和1-(len-1)的最大值
复杂问题 => 子问题 思想
```
4.信件错排问题
描述: 有N个信和信封, 它们被打乱, 求错误装信方式的数量[所有的元素都不在自己原来的位置].
定义一个数组dp存储错误方式数量, dp[i]表示前i个信和信封的错误方式数量.假设第i个信封装到第j个信封里面, 而第j个
信封装到第k个信封里面.根据i和k是否相等,有两种情况:
- i==k,交换i和j的信后, 它们的信和信封在正确的位置, 但是其余i-2封信有dp[i-2]种错误装信方式. 由于j有i-1种取值,
因此共有(i-1)*dp[i-2]种错误装信方式.
- i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 
有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。

综上所述，错误装信数量方式数量为：
dp[i]=(i-1)*dp[i-2]+(i-1)dp[i-1]


5. 母牛生产
程序员代码面试指南-P181

题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。

第 i 年成熟的牛的数量为：
dp[i] = dp[i-1] + dp[i-3]
![](https://camo.githubusercontent.com/b247fc7ff2cf8eac7a48121d4b694ffeeb2c4e97/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38373938313465652d343862352d346263622d383666352d6463633430306362383161642e706e67)