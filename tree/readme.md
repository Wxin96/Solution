### [104\. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/)

Difficulty: **简单**


给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**  
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。


#### Solution

Language: **Java**

```
1. 使用递归
    时间复杂度: O(n)  => 每个节点都要遍历一次(n为树的节点的数量)
    空间复杂度: 递归的最大深度
    空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 N 次（树的高度），因此保持调用栈的存储将是 O(N)。
    但在最好的情况下（树是完全平衡的），树的高度将是 log2(N)。因此，在这种情况下的空间复杂度将是 O(log2(N))。
2. 迭代 BFS   
    使用队列数据结构 一层层 进行广度优先搜索
    时间复杂度: O(n)
    每个节点都遍历到了
    空间复杂度: 平衡树的情况O(n/2) => O(n), 线性表 O(1)
3. 迭代DFS
    时间复杂度: O(n)
    利用深度优先遍历, 遍历了所有节点
    空间复杂度: O(depth) depth:深度的深度
使用: Pair数据结构 树节点, 树节点深度

```
### [110\. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/description/)

Difficulty: **简单**


给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树_每个节点 _的左右两个子树的高度差的绝对值不超过1。

**示例 1:**

给定二叉树 `[3,9,20,null,null,15,7]`

```
    3
   / \
  9  20
    /  \
   15   7
```

返回 `true` 。  

**示例 2:**

给定二叉树 `[1,2,2,3,3,null,null,4,4]`

```
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
```

返回 `false` 。


#### Solution

Language: **Java**

```
1. 自底而上递归
    i,利用成员变量
    ii,利用长度, 出现非平衡二叉树 high=-1
    时间复杂度: O(n)
    空间复杂度: 最差 线性链表O(n)
2. 自上而下递归
    利用平衡二叉树性质
        a. 左右子树长度差小于等于1
        b. 左右子树都是平衡二叉树
    时间复杂度: O(nlog(n))
    空间复杂度: O(n)
注意:
    左右树长度多次遍历使用, 重复性高, 冗余
​
```

### [543\. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/description/)

Difficulty: **简单**


给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**示例 :**  
给定二叉树

```
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

**注意：**两结点之间的路径长度是以它们之间边的数目表示。


#### Solution

Language: **Java**

```
深度优先搜索 递归
问题转化为: 节点的左子树长度 + 右子树长度 最大
时间复杂度: O(n)
空间复杂度:
    O(Height)，其中 HeightHeight 为二叉树的高度
    O(n) n为线性链表 O(log2(n)) n为平衡二叉树
注意:
    设置了成员变量保存最大直径, 深度遍历计算树的长度
​
```

### [226\. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/description/)

Difficulty: **简单**


翻转一棵二叉树。

**示例：**

输入：

```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```

输出：

```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

**备注:**  
这个问题是受到 的 启发的 ：

> 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。


#### Solution

Language: **Java**

```
1. 递归
    每一层 递归左右节点, 并交换左右节点
注意, 交换原则:需要临时变量
    时间复杂度: O(n)
    空间复杂度: O(h) h:树的最高度
2. 迭代法, BFS
    利用队列结构, 进行迭代, 每层交换左右节点
注意, 交换原则:需要临时变量
    时间复杂度: O(n)
    空间复杂度是 O(n)，即使在最坏的情况下，也就是队列里包含了树中所有的节点。对于一颗完整二叉树来说，叶子节点那一层拥有 n/2 = O(n)个节点


```
### [617\. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/description/)

Difficulty: **简单**


给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则**不为 **NULL 的节点将直接作为新二叉树的节点。

**示例 1:**

```
输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
```

**注意:** 合并必须从两个树的根节点开始。


#### Solution

Language: **Java**

```
1. 递归
    时间复杂度: O(n) n:两树中交集节点
    空间复杂度: O(h) h:两颗树的最小深度
注意:
    第一次使用递归犯了一个问题, 忽略树的原结构, 力图遍历所有. 做了冗余的工作, 需要进一步优化
2. DFS迭代
    栈这种数据结构很好的实现了, 深度遍历一挖挖到底的思想
    挖到t2为空, 不挖了;挖到t1为空接上t2
    时间复杂度: O(k) k为t1和t2的交集节点
    空间复杂度: O(h) 最差情况, 满二叉树, h为树的层数-1
体会:
    深度优先遍历, 有前后追溯关系
3. BFS迭代
    利用BFS算法遍历树2, 重塑树t1
    时间复杂度: O(n)  n为树t2的节点数
    空间复杂度: O(n)  n为树t2的节点数, 最差情况:t2为平衡二叉树, n/2
注意:
    t2有节点, t1没有的情况, 我们需要添加t1初始值为0的对应节点
体会:
    广度优先遍历, 根据父子关系, 一层层队列
核心思想:
    遍历t2修改t1 
    ​
```

### [112\. 路径总和](https://leetcode-cn.com/problems/path-sum/description/)

Difficulty: **简单**


给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**   
给定如下二叉树，以及目标和 `sum = 22`，

```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
```

返回 `true`, 因为存在目标和为 22 的根节点到叶子节点的路径 `5->4->11->2`。


#### Solution

Language: **Java**

```
1. 递归
    时间复杂度: O(n) n: 节点数目
    空间复杂度: O(h) h: 树的高度
注意: 递归是要认真分析, 递归终止条件, 是否有冗余代码
2. DFS迭代
    时间复杂度: O(n) n: 节点数目
    空间复杂度: O(h) h: 树的高度 最差情况平衡二叉树, 最好情况单链表O(1)
​
```



