### [104\. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/)

Difficulty: **简单**


给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**  
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。


#### Solution

Language: **Java**

```
1. 使用递归
    时间复杂度: O(n)  => 每个节点都要遍历一次(n为树的节点的数量)
    空间复杂度: 递归的最大深度
    空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 N 次（树的高度），因此保持调用栈的存储将是 O(N)。
    但在最好的情况下（树是完全平衡的），树的高度将是 log2(N)。因此，在这种情况下的空间复杂度将是 O(log2(N))。
2. 迭代 BFS   
    使用队列数据结构 一层层 进行广度优先搜索
    时间复杂度: O(n)
    每个节点都遍历到了
    空间复杂度: 平衡树的情况O(n/2) => O(n), 线性表 O(1)
3. 迭代DFS
    时间复杂度: O(n)
    利用深度优先遍历, 遍历了所有节点
    空间复杂度: O(depth) depth:深度的深度
使用: Pair数据结构 树节点, 树节点深度

```
### [110\. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/description/)

Difficulty: **简单**


给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树_每个节点 _的左右两个子树的高度差的绝对值不超过1。

**示例 1:**

给定二叉树 `[3,9,20,null,null,15,7]`

```
    3
   / \
  9  20
    /  \
   15   7
```

返回 `true` 。  

**示例 2:**

给定二叉树 `[1,2,2,3,3,null,null,4,4]`

```
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
```

返回 `false` 。


#### Solution

Language: **Java**

```
1. 自底而上递归
    i,利用成员变量
    ii,利用长度, 出现非平衡二叉树 high=-1
    时间复杂度: O(n)
    空间复杂度: 最差 线性链表O(n)
2. 自上而下递归
    利用平衡二叉树性质
        a. 左右子树长度差小于等于1
        b. 左右子树都是平衡二叉树
    时间复杂度: O(nlog(n))
    空间复杂度: O(n)
注意:
    左右树长度多次遍历使用, 重复性高, 冗余
​
```

### [543\. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/description/)

Difficulty: **简单**


给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**示例 :**  
给定二叉树

```
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

**注意：**两结点之间的路径长度是以它们之间边的数目表示。


#### Solution

Language: **Java**

```
深度优先搜索 递归
问题转化为: 节点的左子树长度 + 右子树长度 最大
时间复杂度: O(n)
空间复杂度:
    O(Height)，其中 HeightHeight 为二叉树的高度
    O(n) n为线性链表 O(log2(n)) n为平衡二叉树
注意:
    设置了成员变量保存最大直径, 深度遍历计算树的长度
​
```

### [226\. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/description/)

Difficulty: **简单**


翻转一棵二叉树。

**示例：**

输入：

```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```

输出：

```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

**备注:**  
这个问题是受到 的 启发的 ：

> 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。


#### Solution

Language: **Java**

```
1. 递归
    每一层 递归左右节点, 并交换左右节点
注意, 交换原则:需要临时变量
    时间复杂度: O(n)
    空间复杂度: O(h) h:树的最高度
2. 迭代法, BFS
    利用队列结构, 进行迭代, 每层交换左右节点
注意, 交换原则:需要临时变量
    时间复杂度: O(n)
    空间复杂度是 O(n)，即使在最坏的情况下，也就是队列里包含了树中所有的节点。对于一颗完整二叉树来说，叶子节点那一层拥有 n/2 = O(n)个节点


```
### [617\. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/description/)

Difficulty: **简单**


给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则**不为 **NULL 的节点将直接作为新二叉树的节点。

**示例 1:**

```
输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
```

**注意:** 合并必须从两个树的根节点开始。


#### Solution

Language: **Java**

```
1. 递归
    时间复杂度: O(n) n:两树中交集节点
    空间复杂度: O(h) h:两颗树的最小深度
注意:
    第一次使用递归犯了一个问题, 忽略树的原结构, 力图遍历所有. 做了冗余的工作, 需要进一步优化
2. DFS迭代
    栈这种数据结构很好的实现了, 深度遍历一挖挖到底的思想
    挖到t2为空, 不挖了;挖到t1为空接上t2
    时间复杂度: O(k) k为t1和t2的交集节点
    空间复杂度: O(h) 最差情况, 满二叉树, h为树的层数-1
体会:
    深度优先遍历, 有前后追溯关系
3. BFS迭代
    利用BFS算法遍历树2, 重塑树t1
    时间复杂度: O(n)  n为树t2的节点数
    空间复杂度: O(n)  n为树t2的节点数, 最差情况:t2为平衡二叉树, n/2
注意:
    t2有节点, t1没有的情况, 我们需要添加t1初始值为0的对应节点
体会:
    广度优先遍历, 根据父子关系, 一层层队列
核心思想:
    遍历t2修改t1 
    ​
```

### [112\. 路径总和](https://leetcode-cn.com/problems/path-sum/description/)

Difficulty: **简单**


给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**   
给定如下二叉树，以及目标和 `sum = 22`，

```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
```

返回 `true`, 因为存在目标和为 22 的根节点到叶子节点的路径 `5->4->11->2`。


#### Solution

Language: **Java**

```
1. 递归
    时间复杂度: O(n) n: 节点数目
    空间复杂度: O(h) h: 树的高度
注意: 递归是要认真分析, 递归终止条件, 是否有冗余代码
2. DFS迭代
    时间复杂度: O(n) n: 节点数目
    空间复杂度: O(h) h: 树的高度 最差情况平衡二叉树, 最好情况单链表O(1)
​
```
### [437\. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

Difficulty: **简单**


给定一个二叉树，它的每个结点都存放着一个整数值。

找出路径和等于给定数值的路径总数。

路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。

**示例：**

```
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1\.  5 -> 3
2\.  5 -> 2 -> 1
3\.  -3 -> 11
```


#### Solution

Language: **Java**

```
1. 双递归
    一层递归: 遍历所有的节点
    二层递归: 判断当前根节点是否存在路径总和等于给定值
    时间复杂度: 一层递归O(n)[n代表该树当前节点总数], 二层递归O(m)[m代表该树当前节点总数] n + 2logn + .. + n/2*1;
    空间复杂度: 
2. 一层递归
    时间复杂度: O(n)
    空间复杂度: O(n)
    n:节点个数
思考:
    巧妙利用map结构和前n项和
注意:
    1. 根节点初始化 (0, 1) 进入map
    2. 在递归遍历中, 
        - 探索深层, map扩展
        - 递归回溯时, map也收拢, 排除递归完的值
    3. 次序问题, 无序考虑次序, map中存在 当前路径总和 - 目标值 的键值对说明存在这种路径
    sum[m] - sum[n] = sum 核心公式, 秒啊
​
```

### [572\. 另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)

Difficulty: **简单**


给定两个非空二叉树 **s** 和 **t**，检验 **s** 中是否包含和 **t** 具有相同结构和节点值的子树。**s** 的一个子树包括 **s** 的一个节点和这个节点的所有子孙。**s** 也可以看做它自身的一棵子树。

**示例 1:**  
给定的树 s:

```
     3
    / \
   4   5
  / \
 1   2
```

给定的树 t：

```
   4 
  / \
 1   2
```

返回 **true**，因为 t 与 s 的一个子树拥有相同的结构和节点值。

**示例 2:**  
给定的树 s：

```
     3
    / \
   4   5
  / \
 1   2
    /
   0
```

给定的树 t：

```
   4
  / \
 1   2
```

返回 **false**。


#### Solution

Language: **Java**

```
1. 双递归
    一层递归遍历,所有节点
    二层递归, 判断是否匹配
    时间复杂度: O(s*t)   s:s树的节点数目 t:t树的节点数目
    空间复杂度: O(max{ds, dt})   ds:s树的最大深度, dt:t树的最大深度
    
2. DFS暴力匹配[待试]
    这是一种最朴素的方法 —— DFS 枚举 ss 中的每一个节点，判断这个点的子树是否和 tt 相等。
如何判断一个节点的子树是否和 tt 相等呢，我们又需要做一次 DFS 来检查，即让两个指针一开始先指向该节点和 tt 的根，
然后「同步移动」两根指针来「同步遍历」这两棵树，判断对应位置是否相等。
复杂度:
    时间复杂度: O(s*t)   s:s树的节点数目 t:t树的节点数目
    空间复杂度: O(max{ds, dt})   ds:s树的最大深度, dt:t树的最大深度
3. DFS序列串匹配

4. 树哈希

​
```

### [101\. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

Difficulty: **简单**


给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3
```

**进阶：**

你可以运用递归和迭代两种方法解决这个问题吗？


#### Solution

Language: **Java**

```
1. 递归(从根节点左右节点开始遍历)
   时间复杂度: O(n/2)  [满二叉树, 父子树的关系]
   空间复杂度: O(log2(n))
体会: 一个方法要认真考虑才知道能不能实行, 用笔去算去推演, 空想误人子弟
2.迭代方法
    时间复杂度: O(n)  n:树的节点数目
    空间复杂度: O(hn) hn: 树的深度, log2(n), 最坏情况下: 平衡二叉树​
体会: 往常BFS是一层层遍历, 此处采用一个一个按照原层级顺序输出, 不同题目, 算法变换, 妙绝

```
### [111\. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

Difficulty: **简单**


给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**

给定二叉树 `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最小深度  2.


#### Solution

Language: **Java**

```
1. 递归
   时间复杂度: O(n)  n: 树节点的个数
   空间复杂度: O(n) O(log2(n))   与树的深度有关
2. BFS和DFS都可以
    利用queue\stack Pair绑定深度, 遍历最小深度的叶子节点
    时间复杂度: O(n)
    空间复杂度: O(n)
​总结:
    1. 叶子节点的概念理解
注意:
    程序中对叶子节点的处理, if (left == 0 || right == 0) return left + right + 1;巧妙设计
```

### [404\. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

Difficulty: **简单**


计算给定二叉树的所有左叶子之和。

**示例：**

```
    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```


#### Solution

Language: **Java**

```
1. 递归
   时间复杂度: O(n) n:树的节点数
   空间复杂度: O(h) h:树的深度
难点: 如何判断是左节点
    1. 传参数
    2. 在父节点进行计算
2.迭代DFS
    时间复杂度: O(n) n:节点数目
    空间复杂度: O(h) h:树的深度
    ​
```
### [687\. 最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/)

Difficulty: **简单**


给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。

**注意**：两个节点之间的路径长度由它们之间的边数表示。

**示例 1:**

输入:

```
              5
             / \
            4   5
           / \   \
          1   1   5
```

输出:

```
2
```

**示例 2:**

输入:

```
              1
             / \
            4   5
           / \   \
          4   4   5
```

输出:

```
2
```

**注意:** 给定的二叉树不超过10000个结点。 树的高度不超过1000。


#### Solution

Language: **Java**

```
1. 递归
    时间复杂度: O(n)  n:节点数目
    空间复杂度: O(h)  h:树的深度
注意:
    当前节点, 相同数值, 是包括左右节点
    向上传递时, 只传递最大数目相同节点
总结:
    理清楚递归之间的层级关系, 递归截至怎么处理的, 递归结束怎么处理的.
​
```
### [337\. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/description/)

Difficulty: **中等**


在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

**示例 1:**

```
输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
```

**示例 2:**

```
输入: [3,4,5,1,3,null,1]

     3
    / \
   4   5
  / \   \ 
 1   3   1

输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
```


#### Solution

Language: **Java**

```
1. 
​
```
### [671\. 二叉树中第二小的节点](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/description/)

Difficulty: **简单**


给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 `2` 或 `0`。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。 

给出这样的一个二叉树，你需要输出所有节点中的**第二小的值。**如果第二小的值不存在的话，输出 -1 **。**

**示例 1:**

```
输入: 
    2
   / \
  2   5
     / \
    5   7

输出: 5
说明: 最小的值是 2 ，第二小的值是 5 。
```

**示例 2:**

```
输入: 
    2
   / \
  2   2

输出: -1
说明: 最小的值是 2, 但是不存在第二小的值。
```


#### Solution

Language: **Java**

```
1. 递归(递归典型题目)
   时间复杂度: O(n)  n:节点个数
   空间复杂度: O(h)  h:树的高度
思考:
   递归最小单位: /\ 三个节点的二叉树
   对于这个递归最小单位, 我们获取左右子节点的值.
   左右子节点都不等于根节点, 由题意知道, 大于根节点, 我们能得到递归结果了, 无需继续递归了
   如果有子节点等于根节点, 说明存在未知, 需要继续递归
   递归回溯判断左右节点的值, 是否是-1
2. 暴力法, 遍历所有的节点, 找到倒数第二小的数值, 存在返回, 不存在则返回-1​

```

