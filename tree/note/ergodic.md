### [144\. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/)

Difficulty: **中等**


给定一个二叉树，返回它的 _前序 _遍历。

 **示例:**

```
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]
```

**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？


#### Solution

Language: **Java**

```
1. DFS迭代算法
   时间复杂度: O(n)  n:节点个数
   空间复杂度: O(n)  n:节点个数 list和stack
2.递归
    时间复杂度: O(n)  n:节点个数
    空间复杂度: O(n)  n:节点个数 list
​3.Morris遍历
    时间复杂度: O(n)  n:节点个数
    空间复杂度: O(n)  n:节点个数 list
```
### [145\. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

Difficulty: **困难**


给定一个二叉树，返回它的 _后序 _遍历。

**示例:**

```
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
```

**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？


#### Solution

Language: **Java**

```
1.迭代法
    时间复杂度: O(n)  n:树的节点个数
    空间复杂度: O(n)  n:树的节点个数 list和stack
    后序遍历: 左 -> 右 -> 根
    改造前序: 根 -> 右 -> 左
2.迭代法
    思想一: set记录遍历过的点
    时间复杂度: O(n)
    空间复杂度: O(n)  list
3.迭代法
    思想二: 记录上此遍历的点
    遍历次序: 左 -> (根节点) -> 右 ->根节点
    思考 /\ 结构(根左右)
    我们可以根据上次节点是不是右节点来判断是否需要向右递归
    时间复杂度: O(n)
    空间复杂度: O(n)  list
4.迭代法
    思想三: 每个节点压栈两次, 根据是否存在重复, 判断右节点归去
    双栈作用: 第一个次目的添加左右节点, 第二次打印当前值
    时间复杂度: O(n)
    空间复杂度: O(2h) h:树的深度
5.Morris遍历法
    时间复杂度: O(n)
    空间复杂度: O(n)  list
```
### [94\. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/description/)

Difficulty: **中等**


给定一个二叉树，返回它的_中序 _遍历。

**示例:**

```
输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
```

**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？


#### Solution

Language: **Java**

```
1.递归:新的递归函数, 加入传递的中间变量
    时间复杂度: O(n)
    空间复杂度: O(n)
2.别人家的迭代: 实际模拟递归过程(核心: 未遍历过的左节点递归到底, 右节点一个一个遍历, 再查看右节点的左节点)
    时间复杂度: O(n)
    空间复杂度: O(n)​
3.解法三: Morris Traversal
    时间复杂度: O(n)
    空间复杂度: O(1)
个人认为空间复杂度: O(n) => ans数组
体会: 左三角形 扩展 右三角形
```