### [637\. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/description/)

Difficulty: **简单**


给定一个非空二叉树, 返回一个由每层节点平均值组成的数组.

**示例 1:**

```
输入:
    3
   / \
  9  20
    /  \
   15   7
输出: [3, 14.5, 11]
解释:
第0层的平均值是 3,  第1层是 14.5, 第2层是 11\. 因此返回 [3, 14.5, 11].
```

**注意：**

1.  节点值的范围在32位有符号整数范围内。


#### Solution

Language: **Java**

```
1.BFS遍历
    时间复杂度: O(n)  n:节点数目
    空间复杂度: O(max(w, h))  w:树的宽度(queue) h:树的深度(list)
两种方式迭代: 
(1).一层一层
(2).按从左到右的顺序, 一个一个
2.DFS递归
    时间复杂度: O(n)  n:节点数目
    空间复杂度: O(h)  h:树的深度
​DFS解决这道题,
1. 根据层数累计每层
2. 再设置一变量, 统计累加个数
总结:
    有可能一道题,直接想到的是比较最直接的想法, 可是从另一种解法找可能性.
    树一般都用 DFS 和BFS 递归和迭代
```
### [513\. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

Difficulty: **中等**


给定一个二叉树，在树的最后一行找到最左边的值。

**示例 1:**

```
输入:

    2
   / \
  1   3

输出:
1
```

**示例 2:**

```
输入:

        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

输出:
7
```

**注意:** 您可以假设树（即给定的根节点）不为 **NULL**。


#### Solution

Language: **Java**

```
1.BFS迭代
    (个人想到: BFS一层层)
    (CyC2018 一个个BFS 次序:右->左)
    时间复杂度: O(n)  n:节点数
    空间复杂度: O(w)  w:树的最大宽度
2.DFS-中序遍历(递归)
    目标找到: 深度最深,并且第一次遍历到这个深度的数值
    中序遍历: 左 -> 中 -> 右
    时间复杂度: O(n)  n:节点数
    空间复杂度: O(h)  h:树的最大深度
```