### [669\. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/description/)

Difficulty: **简单**


给定一个二叉搜索树，同时给定最小边界`L` 和最大边界 `R`。通过修剪二叉搜索树，使得所有节点的值在`[L, R]`中 (R>=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。

**示例 1:**

```
输入: 
    1
   / \
  0   2

  L = 1
  R = 2

输出: 
    1
      \
       2
```

**示例 2:**

```
输入: 
    3
   / \
  0   4
   \
    2
   /
  1

  L = 1
  R = 3

输出: 
      3
     / 
   2   
  /
 1
```


#### Solution

Language: **Java**

```
1.递归
时间复杂度: O(n) n:树的节点数目
空间复杂度: O(h) h:树的高度
思想: 
 1.当前节点的值 < L, 去右区间检查是否存在符合条件的节点
 2.当前节点的值 > R, 去左区间检查是否存在符合条件的节点
 3.当前结点的值 在[L, R]闭区间中, 符合条件正常传递
​
递归修建枝叶
思想: 
    1. 符合条件, 父子关系不变
    2. 不符合条件, 递归传递中跳过不符合条件的节点, 返回深层符合条件的节点, 实现BST的修枝剪叶
```