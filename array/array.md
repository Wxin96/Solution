### [283\. 移动零](https://leetcode-cn.com/problems/move-zeroes/description/)

Difficulty: **简单**


给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**示例:**

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**说明**:

1.  必须在原数组上操作，不能拷贝额外的数组。
2.  尽量减少操作次数。


#### Solution

Language: **Java**

```
1.遍历
思路: 非零元素往前排, 剩余元素设置为0
上思路有雏形, 但不知道具体代码怎么写
    时间复杂度: O(n)
    空间负载的: O(1)
2.类似快排
这里参考了快速排序的思想，快速排序首先要确定一个待分割的元素做中间点x，然后把所有小于等于x的元素放到x的左边，大于x的元素放到其右边。
这里我们可以用0当做这个中间点，把不等于0(注意题目没说不能有负数)的放到中间点的左边，等于0的放到其右边。
这的中间点就是0本身，所以实现起来比快速排序简单很多，我们使用两个指针i和j，只要nums[i]!=0，我们就交换nums[i]和nums[j]
时间复杂度: O(n)
空间复杂度: O(1)
过程复盘, 起始i和pivot是同步的, 直到遇到0,二者岔开
```
### [566\. 重塑矩阵](https://leetcode-cn.com/problems/reshape-the-matrix/description/)

Difficulty: **简单**


在MATLAB中，有一个非常有用的函数 `reshape`，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。

给出一个由二维数组表示的矩阵，以及两个正整数`r`和`c`，分别表示想要的重构的矩阵的行数和列数。

重构后的矩阵需要将原始矩阵的所有元素以相同的**行遍历顺序**填充。

如果具有给定参数的`reshape`操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。

**示例 1:**

```
输入: 
nums = 
[[1,2],
 [3,4]]
r = 1, c = 4
输出: 
[[1,2,3,4]]
解释:
行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。
```

**示例 2:**

```
输入: 
nums = 
[[1,2],
 [3,4]]
r = 2, c = 4
输出: 
[[1,2],
 [3,4]]
解释:
没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。
```

**注意：**

1.  给定矩阵的宽和高范围在 [1, 100]。
2.  给定的 r 和 c 都是正数。


#### Solution

Language: **Java**

```
566.重塑矩阵
    考察二维矩阵的线性遍历
1.一次遍历
    时间复杂度: O(r*c)
    空间复杂度: O(r*c)
一维数组到二维数组的映射
​
2.使用队列, 两次遍历
    时间复杂度: O(r*c)
    空间复杂度: O(r*c)
```
### [485\. 最大连续1的个数](https://leetcode-cn.com/problems/max-consecutive-ones/)

Difficulty: **简单**


给定一个二进制数组， 计算其中最大连续1的个数。

**示例 1:**

```
输入: [1,1,0,1,1,1]
输出: 3
解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.
```

**注意：**

*   输入的数组只包含 `0` 和`1`。
*   输入数组的长度是正整数，且不超过 10,000。


#### Solution

Language: **Java**

```
1.一次遍历
    时间复杂度: O(n)   n: 数组元素数
    空间复杂度: O(1)
问题:
     最后一个数需要多加一次处理, 不都优雅
​两种改善方式,
    1.省去返回时多余的变量
    2.循环中, 长度边能增加边都比较
```
### [240\. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/description/)

Difficulty: **中等**


编写一个高效的算法来搜索 _m_ x _n_ 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：

*   每行的元素从左到右升序排列。
*   每列的元素从上到下升序排列。

**示例:**

现有矩阵 matrix 如下：

```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```

给定 target = `5`，返回 `true`。

给定 target = `20`，返回 `false`。


#### Solution

Language: **Java**

```
3.暴力法
    时间复杂度: O(m*n)
    空间复杂度: O(1)
2.每一行进行二分搜索
    时间复杂度的话，如果是 m 行 n 列，就是 O(m*log2(n))。
​1.从右上角开始查找(左下也可以, 能减小搜索区域)
 左上和右下是不行的, 这两个角无法减少搜索区域
 时间复杂度: O(m+n) m n: 数组的宽和高
 空间复杂度: O(1)
```
### [378\. 有序矩阵中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)

Difficulty: **中等**


给定一个 _n x n _矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。  
请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。

**示例:**

```
matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。
```

**提示：**  
你可以假设 k 的值永远是有效的, 1 ≤ k ≤ n<sup>2 </sup>。


#### Solution

Language: **Java**

```
1.使用小顶堆数据结构
    问题: 
        并没有利用矩阵行升序和列升序的性质
    时间复杂度: O(n) n: 矩阵元素数目 [缺失堆的时间复杂度]
    空间复杂度: O(n)
2.二分查找
    思想: 
        此处二分查找的不再是元素, 而是矩阵元素的数值范围
    提示: 
        思维不能局限, 学习的很多算法, 要会变换应用
    时间复杂度: O(n*log2(n)) n: 矩阵种元素的数值范围
    空间复杂度: O(1)
3.堆解法2
利用了矩阵行升序和列升序的性质
思想: 
    现存第一行数据, 利用矩阵的行升序和列升序的性质, 去除(k-1)小顶堆中最小值, 并找它所在列下一个元素进队列(如果有下一个元素的话)
    此种方法去除了矩阵中的k-1个最小值, 此时第k个最小值在小顶堆根节点
    时间复杂度: O(n+k)    n:矩阵列数
    空间复杂度: O(n)
```
### [645\. 错误的集合](https://leetcode-cn.com/problems/set-mismatch/description/)

Difficulty: **简单**


集合 `S` 包含从1到 `n` 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。

给定一个数组 `nums` 代表了集合 `S` 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

**示例 1:**

```
输入: nums = [1,2,2,4]
输出: [2,3]
```

**注意:**

1.  给定数组的长度范围是 [2, 10000]。
2.  给定的数组是无序的。


#### Solution

Language: **Java**

```
645. 错误的集合
 说明:
     1.给定数组的长度范围是 [2, 10000]。
     2.给定的数组是无序的。
     数组: 0-(n-1)
     元素: 1-n
     数组索引和元素是线性关系
​1.诸神归位
    交换时使用的是while(重复元素会阻挡, 一定要换到是当前索引对应数值)
    另外, 需要确定要交换的元素索引和位置不对应, 负责会产生死循环.
    时间复杂度: O(n)
    空间复杂度: O(1)
2.排序
    时间复杂度: O(n*log2(n))
    空间复杂度: O(1)
```
### [287\. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/description/)

Difficulty: **中等**


给定一个包含 _n_ + 1 个整数的数组 _nums_，其数字都在 1 到 _n _之间（包括 1 和 _n_），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

**示例 1:**

```
输入: [1,3,4,2,2]
输出: 2
```

**示例 2:**

```
输入: [3,1,3,4,2]
输出: 3
```

**说明：**

1.  **不能**更改原数组（假设数组是只读的）。
2.  只能使用额外的 _O_(1) 的空间。
3.  时间复杂度小于 _O_(_n_<sup>2</sup>) 。
4.  数组中只有一个重复的数字，但它可能不止重复出现一次。


#### Solution

Language: **Java**

```
类型题: 数组映射链表
1.二分查找
思想: 已知数组的范围, 根据范围二分查找到重复的数. 正常 left-mid范围内有 mid - left +1个数
    时间复杂度: O(n*log2(n))
    空间复杂度: O(1)
2.双指针(环的入口点)
为什么能形成环, 而且是在开头第一个环中, 首先这个映射关系一定能形成环, 长度为n+1, 数字都在 1-n中
没有0, 由第一个元素形成环无法闭合, 其他闭合是自闭和与0索引元素没有交集. 把0元素改成重复元素, 之前的闭环, 变成-O
数组这种映射关系形成一个链表, 重复元素为进闭环索引, 采用快慢指针寻找此索引
    时间复杂度: O(n)  n: 数组元素数目
    空间复杂度: O(1)
```
### [667\. 优美的排列 II](https://leetcode-cn.com/problems/beautiful-arrangement-ii/description/)

Difficulty: **中等**


给定两个整数 `n` 和 `k`，你需要实现一个数组，这个数组包含从 `1` 到 `n` 的 `n` 个不同整数，同时满足以下条件：

① 如果这个数组是 [a<sub style="display: inline;">1</sub>, a<sub style="display: inline;">2</sub>, a<sub style="display: inline;">3</sub>, ... , a<sub style="display: inline;">n</sub>] ，那么数组 [|a<sub style="display: inline;">1</sub> - a<sub style="display: inline;">2</sub>|, |a<sub style="display: inline;">2</sub> - a<sub style="display: inline;">3</sub>|, |a<sub style="display: inline;">3</sub> - a<sub style="display: inline;">4</sub>|, ... , |a<sub style="display: inline;">n-1</sub> - a<sub style="display: inline;">n</sub>|] 中应该有且仅有 k 个不同整数；.

② 如果存在多种答案，你只需实现并返回其中任意一种.

**示例 1:**

```
输入: n = 3, k = 1
输出: [1, 2, 3]
解释: [1, 2, 3] 包含 3 个范围在 1-3 的不同整数， 并且 [1, 1] 中有且仅有 1 个不同整数 : 1
```

**示例 2:**

```
输入: n = 3, k = 2
输出: [1, 3, 2]
解释: [1, 3, 2] 包含 3 个范围在 1-3 的不同整数， 并且 [2, 1] 中有且仅有 2 个不同整数: 1 和 2
```

**提示:**

1.  `n` 和 `k` 满足条件 1 <= k < n <= 10<sup>4</sup>.


#### Solution

Language: **Java**

```
667.优美的排列 II
    一个找规律题目,
​2.更好的规律(CyC2018)
    时间复杂度: O(n)  n: 数组元素数目
    空间复杂度: O(n)
    把数组分为三部分
    第一部分: 1            [1]
    第二部分: k+1 2 ...    [k个, 间隔--]
    第三部分: k+2...n      [n-k-1]
3.反转法
    时间复杂度: O(n^2)
    空间复杂度: O(n)
```
### [697\. 数组的度](https://leetcode-cn.com/problems/degree-of-an-array/)

Difficulty: **简单**


给定一个非空且只包含非负数的整数数组 `nums`, 数组的度的定义是指数组里任一元素出现频数的最大值。

你的任务是找到与 `nums` 拥有相同大小的度的最短连续子数组，返回其长度。

**示例 1:**

```
输入: [1, 2, 2, 3, 1]
输出: 2
解释: 
输入数组的度是2，因为元素1和2的出现频数最大，均为2.
连续子数组里面拥有相同度的有如下所示:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
最短连续子数组[2, 2]的长度为2，所以返回2.
```

**示例 2:**

```
输入: [1,2,2,3,1,4,2]
输出: 6
```

**注意:**

*   `nums.length` 在1到50,000区间范围内。
*   `nums[i]` 是一个在0到49,999范围内的整数。


#### Solution

Language: **Java**

```
697. 数组的度
利用三个哈希表(HashMap):
    第一个记录: 元素出现次数
    第二个记录: 元素第一次出现的位置
    第三个记录: 元素最后一次出现的位置
​1.哈希记录
    时间复杂度: O(n)
    空间复杂度: O(n)
2.暴力解法
    时间复杂度: O(n^2)
    空间复杂度: O(1)
```
### [766\. 托普利茨矩阵](https://leetcode-cn.com/problems/toeplitz-matrix/description/)

Difficulty: **简单**


如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是_托普利茨矩阵_。

给定一个 `M x N` 的矩阵，当且仅当它是_托普利茨矩阵_时返回 `True`。

**示例 1:**

```
输入: 
matrix = [
  [1,2,3,4],
  [5,1,2,3],
  [9,5,1,2]
]
输出: True
解释:
在上述矩阵中, 其对角线为:
"[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]"。
各条对角线上的所有元素均相同, 因此答案是True。
```

**示例 2:**

```
输入:
matrix = [
  [1,2],
  [2,2]
]
输出: False
解释: 
对角线"[1, 2]"上的元素不同。
```

**说明:**

1.  `matrix` 是一个包含整数的二维数组。
2.  `matrix` 的行数和列数均在 `[1, 20]`范围内。
3.  `matrix[i][j]` 包含的整数在 `[0, 99]`范围内。

**进阶:**

1.  如果矩阵存储在磁盘上，并且磁盘内存是有限的，因此一次最多只能将一行矩阵加载到内存中，该怎么办？
2.  如果矩阵太大以至于只能一次将部分行加载到内存中，该怎么办？


#### Solution

Language: **Java**

```
1.对角线回溯
思想:
    利用递归判断M+N个对角线是否符合要求
    时间复杂度: O(M*N) 即: 矩阵大小
    空间复杂度: O(N)  递归深度
​2.检查左上角邻居
    时间复杂度: O(M*N) 即: 矩阵大小
    空间复杂度: O(1)
3.同一对角线元素, r-c的值相同, 利用HashMap存储
    时间复杂度: O(M*N) 即: 矩阵大小
    空间复杂度: O(M+N)    对角线元素个数
```
### [565\. 数组嵌套](https://leetcode-cn.com/problems/array-nesting/description/)

Difficulty: **中等**


索引从`0`开始长度为`N`的数组`A`，包含`0`到`N - 1`的所有整数。找到最大的集合`S`并返回其大小，其中 `S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }`且遵守以下的规则。

假设选择索引为`i`的元素`A[i]`为`S`的第一个元素，`S`的下一个元素应该是`A[A[i]]`，之后是`A[A[A[i]]]...` 以此类推，不断添加直到`S`出现重复的元素。

**示例 1:**

```
输入: A = [5,4,0,3,1,6,2]
输出: 4
解释: 
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.

其中一种最长的 S[K]:
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}
```

**提示：**

1.  `N`是`[1, 20,000]`之间的整数。
2.  `A`中不含有重复的元素。
3.  `A`中的元素大小在`[0, N-1]`之间。


#### Solution

Language: **Java**

```
[数组映射链表类型题]
565. 数组嵌套
    数组长度: n
    数的范围: 0~(n-1)
    长度与数映射
3.暴力法
每个元素都进行循环, 测长度
    时间复杂度: O(n^2)  n:元素数目
    最差情况: [1, 2, 3, 4, 5, 0]
    空间复杂度: O(1)
2.使用额外空间, 创建n长度的布尔变量
    时间复杂度: O(n)  n:元素数目
    空间复杂度: O(n)
​1.不使用额外空间, 一次遍历法
    时间复杂度: O(n)  n:元素数目
    空间复杂度: O(1)
```
### [769\. 最多能完成排序的块](https://leetcode-cn.com/problems/max-chunks-to-make-sorted/description/)

Difficulty: **中等**


数组`arr`是`[0, 1, ..., arr.length - 1]`的一种排列，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。

我们最多能将数组分成多少块？

**示例 1:**

```
输入: arr = [4,3,2,1,0]
输出: 1
解释:
将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。
```

**示例 2:**

```
输入: arr = [1,0,2,3,4]
输出: 4
解释:
我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。
然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。
```

**注意:**

*   `arr` 的长度在 `[1, 10]` 之间。
*   `arr[i]`是 `[0, 1, ..., arr.length - 1]`的一种排列。


#### Solution

Language: **Java**

```
769. 最多能完成排序的块
    考察问题转化
​1.区域内最大索引 = 最大值
    时间复杂度: O(n)
    空间复杂度: O(1)
```






























